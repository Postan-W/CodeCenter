**Author:wmingzhu**

## Version1.0(2022/08)

### 原则

一个人第一个时间点存在于检测区域，第二个时间点也存在于检测区域，由于在两个时间点都被检测到了，两个时间点之间有一个设定的时间间隔，这里算法认为该人是滞留状态。这样的判断方式比较粗糙，因为一个人可能离开后再回来，在第二次检测时没有被检测到,但是在第二次检测时间点之后又回到了该区域，那么这种情况的滞留就被漏检了。显然，连续n个时间点进行匹配对比可以提高判断滞留的准确性，比如连续n个时间点，第一个和最后一个都检测到该目标，并且中间n'(n'可以设定为[1,n-2]之间的一个数)个时间点也都检测到了该目标，那么就认为是滞留。不过显然点数的增加导致计算量大幅度增加。这里采用最简单的两个相邻时间点的匹配作为判断依据。

### 实现方法

每个摄像头对应一个定时任务，前一个任务未完成，后一个任务不开始。每个摄像头执行相同的逻辑。

**detections下图片命名方法：**

camera{x}\_(origin)time{1/2}\_{n}.jpeg

x代表第x个摄像头；(origin)time{1/2}，其中time{1/2}代表时间点1或2检测到的人，origintime{1/2}代表时间点1或2检测到的人对应的完整图(即框出了目标的原frame)，最后的{n}是图片的编号。例如camera0_time1_2.jpeg代表camera0在检测点1获取到的第2个目标。

**results下的图片命名方法：**

两个时间点匹配到的图片的完整图将放在这里。

camera{x}{a/b}{n}.jpeg，结果都是couple形式的图片，例如camera0a10.jpeg,camera0b10.jpeg是camera0捕获的第10对匹配图片。

**匹配逻辑：**

根据detections下的图片名称判断该次任务摄像头x是处于第几个时间点，若处于第一个时间点(即不存在camerax_time1_n.jpeg这样的图片),那么就只执行检测，然后保存检测到的人；若处于第二个时间点执行检测，然后将匹配的结果放到results目录下，之后将该摄像头两个时间点的4种图片全部删除，然后立即执行新的匹配。这样一个周期结束。

### 项目结构

![](./%E4%BA%BA%E5%91%98%E6%BB%9E%E7%95%99%E6%A3%80%E6%B5%8B.png)

