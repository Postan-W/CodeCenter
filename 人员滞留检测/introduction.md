**Author:wmingzhu**

## Version1.0(2022/08)

### 原则

一个人第一个时间点存在于检测区域，第二个时间点也存在于检测区域，由于在两个时间点都被检测到了，两个时间点之间有一个设定的时间间隔，这里算法认为该人是滞留状态。这样的判断方式比较粗糙，因为一个人可能离开后再回来，在第二次检测时没有被检测到,但是在第二次检测时间点之后又回到了该区域，那么这种情况的滞留就被漏检了。显然，连续n个时间点进行匹配对比可以提高判断滞留的准确性，比如连续n个时间点，第一个和最后一个都检测到该目标，并且中间n'(n'可以设定为[1,n-2]之间的一个数)个时间点也都检测到了该目标，那么就认为是滞留。不过显然点数的增加导致计算量大幅度增加。这里采用最简单的两个相邻时间点的匹配作为判断依据。

### 实现方法

- 步骤1

  进行一次检测，将一次检测到的人截取下来放在person_images/time1目录下，将包含该人目标框的原帧图像放在person_images/detectons1目录下，在命名方式上将两个文件夹下的图片对应；时间t后进行下一次检测，得到person_images/time2，以及person_images/detections2;

  for p1 in 文件夹time1:

  ​	for p2 in 文件夹time2：

  ​		if matching(p1,p2):

  ​			返回detections1和detections2下面的对应图片，形成一个二元tuple，添加到一个总的list中；这样做的好处是接收者还可以通过对比两张图片来进一步判断是否真的是同一个人。

  清空上述4个文件夹下的图片；

- 步骤2

  步骤1中清空文件夹后立即进行下一个周期，即进行一次检测，时间t后进行第二次检测。

很显然，对于长时间滞留的目标来说(即滞留时间比检测时间间隔t大很多)，如果算法匹配准确度高，那么对于该人的滞留提示每t时间就会有一次。

### 项目结构

![](images/%E4%BA%BA%E5%91%98%E6%BB%9E%E7%95%99%E6%A3%80%E6%B5%8B.png)
